common:
  global:
    # -- Set an override for the prefix of the fullname
    nameOverride:
    # -- Set the entire name definition
    fullnameOverride:
    # -- Set additional global labels. Helm templates can be used.
    labels: {}
    # -- Set additional global annotations. Helm templates can be used.
    annotations: {}

  defaultPodOptions:
    # -- Defines affinity constraint rules.
    # [[ref]](https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity)
    affinity: {}
    # -- Set annotations on the Pod. Pod-specific values will be merged with this.
    annotations: {}
    # -- Specifies whether a service account token should be automatically mounted.
    automountServiceAccountToken: true
    # -- Configuring the ndots option may resolve nslookup issues on some Kubernetes setups.
    dnsConfig: {}
    # -- Defaults to "ClusterFirst" if hostNetwork is false and "ClusterFirstWithHostNet" if hostNetwork is true.
    dnsPolicy: ""
    # -- Enable/disable the generation of environment variables for services.
    # [[ref]](https://kubernetes.io/docs/concepts/services-networking/connect-applications-service/#accessing-the-service)
    enableServiceLinks: false
    # -- Allows specifying explicit hostname setting
    hostname: ""
    # -- Use hostAliases to add custom entries to /etc/hosts - mapping IP addresses to hostnames.
    # [[ref]](https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/)
    hostAliases: []
    # -- Use the host's ipc namespace
    hostIPC: false
    # -- When using hostNetwork make sure you set dnsPolicy to `ClusterFirstWithHostNet`
    hostNetwork: false
    # -- Use the host's pid namespace
    hostPID: false
    # -- Set image pull secrets
    imagePullSecrets: []
    # -- Set labels on the Pod. Pod-specific values will be merged with this.
    labels: {}
    # -- Node selection constraint
    # [[ref]](https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector)
    nodeSelector: {}
    # -- Custom priority class for different treatment by the scheduler
    priorityClassName: ""
    # -- Set Container restart policy.
    # @default -- `Always`. When `controller.type` is `cronjob` it defaults to `Never`.
    restartPolicy: ""
    # -- Allow specifying a runtimeClassName other than the default one (ie: nvidia)
    runtimeClassName: ""
    # -- Allows specifying a custom scheduler name
    schedulerName: ""
    # -- Configure the Security Context for the Pod
    securityContext:
      runAsUser: 1000
      runAsGroup: 1000
      fsGroup: 1000
      fsGroupChangePolicy: "OnRootMismatch"
    # -- Duration in seconds the pod needs to terminate gracefully
    # -- [[ref](https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#lifecycle)]
    terminationGracePeriodSeconds:
    # -- Specify taint tolerations
    # [[ref]](https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/)
    tolerations: []
    # -- Defines topologySpreadConstraint rules.
    # [[ref]](https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/)
    topologySpreadConstraints: []

  controllers:
    main:
      # -- enable the controller.
      enabled: true
      # -- Set the controller type.
      # Valid options are deployment, daemonset, statefulset, cronjob or job
      type: deployment
      # -- Set annotations on the deployment/statefulset/daemonset/cronjob/job
      annotations: {}
      # -- Set labels on the deployment/statefulset/daemonset/cronjob/job
      labels: {}
      # -- Number of desired pods. When using a HorizontalPodAutoscaler, set this to `null`.
      replicas: 1
      # -- Set the controller upgrade strategy
      # For Deployments, valid values are Recreate (default) and RollingUpdate.
      # For StatefulSets, valid values are OnDelete and RollingUpdate (default).
      # DaemonSets/CronJobs/Jobs ignore this.
      strategy: Recreate
      # -- ReplicaSet revision history limit
      revisionHistoryLimit: 3

      # -- Container
      containers:
        main:
          # -- Override the container name
          nameOverride:
          # -- Specify if this container depends on any other containers
          # This is used to determine the order in which the containers are rendered.
          dependsOn: []
          # -- Image
          image:
            # -- image repository
            repository: lscr.io/linuxserver/lazylibrarian
            # -- image tag
            tag: version-b3a081ec
            # -- image pull policy
            pullPolicy: IfNotPresent
          # -- Override the command(s) for the default container
          command: []
          # -- Override the args for the default container
          args: []
          # -- Override the working directory for the default container
          workingDir:
          # -- Environment variables. Template enabled.
          env:
            PUID: 1000
            PGID: 1000
            TZ: US/Mountain
            DOCKER_MODS: linuxserver/mods:universal-calibre|linuxserver/mods:lazylibrarian-ffmpeg
          # -- Secrets and/or ConfigMaps that will be loaded as environment variables.
          envFrom: []
          # -- Set the resource requests / limits for the container.
          resources:
            ## We usually recommend not to specify default resources and to leave this as a conscious
            ## choice for the user. This also increases chances charts run on environments with little
            ## resources, such as Minikube. If you do want to specify resources, uncomment the following
            ## lines, adjust them as necessary, and remove the curly braces after 'resources:'.
            limits:
              cpu: 500m
              memory: 512Mi
            requests:
              cpu: 10m
              memory: 256Mi

  serviceAccount:
    # -- Specifies whether a service account should be created
    create: true
    # -- Annotations to add to the service account
    annotations: {}
    # -- Labels to add to the service account
    labels: {}
    # -- The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  service:
    main:
      # -- Enables or disables the service
      enabled: true
      # -- Override the name suffix that is used for this service
      nameOverride: ""
      # -- Configure which controller this service should target
      controller: main
      # -- Make this the primary service for this controller (used in probes, notes, etc...).
      # If there is more than 1 service targeting the controller, make sure that only 1 service is
      # marked as primary.
      primary: true
      # -- Set the service type
      type: ClusterIP
      # -- Specify the externalTrafficPolicy for the service. Options: Cluster, Local
      # -- [[ref](https://kubernetes.io/docs/tutorials/services/source-ip/)]
      externalTrafficPolicy:
      # -- Specify the ip policy. Options: SingleStack, PreferDualStack, RequireDualStack
      ipFamilyPolicy:
      # -- The ip families that should be used. Options: IPv4, IPv6
      ipFamilies: []
      # -- Provide additional annotations which may be required.
      annotations: {}
      # -- Provide additional labels which may be required.
      labels: {}
      # -- Allow adding additional match labels
      extraSelectorLabels: {}
      # -- Configure the Service port information here.
      # Additional ports can be added by adding a dictionary key similar to the 'http' service.
      # @default -- See below
      ports:
        http:
          # -- Enables or disables the port
          enabled: true
          # -- Make this the primary port (used in probes, notes, etc...)
          # If there is more than 1 service, make sure that only 1 port is marked as primary.
          primary: true
          # -- The port number
          port: 5299
          # -- Port protocol.
          # Support values are `HTTP`, `HTTPS`, `TCP` and `UDP`.
          # HTTP and HTTPS spawn a TCP service and get used for internal URL and name generation
          protocol: HTTP
          # -- Specify a service targetPort if you wish to differ the service port from the application port.
          # If `targetPort` is specified, this port number is used in the container definition instead of
          # the `port` value. Therefore named ports are not supported for this field.
          targetPort:
          # -- Specify the nodePort value for the LoadBalancer and NodePort service types.
          # [[ref]](https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport)
          nodePort:
          # -- Specify the appProtocol value for the Service.
          # [[ref]](https://kubernetes.io/docs/concepts/services-networking/service/#application-protocol)
          appProtocol:

  ingress:
    # -- An example is shown below
    main:
      # -- Enables or disables the ingress
      enabled: true
      # -- Override the name suffix that is used for this ingress.
      nameOverride:
      # -- Provide additional annotations which may be required.
      annotations: {}
      # -- Provide additional labels which may be required.
      labels: {}
      # -- Set the ingressClass that is used for this ingress.
      className:
      # -- Configure the defaultBackend for this ingress. This will disable any other rules for the ingress.
      defaultBackend:
      ## Configure the hosts for the ingress
      hosts:
        - # -- Host address. Helm template can be passed.
          host: chart-example.local
          ## Configure the paths for the host
          paths:
            - # -- Path.  Helm template can be passed.
              path: /
              pathType: Prefix
              service:
                # -- The service name to reference.
                name: main
                # -- The service port number reference for this path
                port: 5299
      # -- Configure TLS for the ingress. Both secretName and hosts can process a Helm template.
      tls: []
      #  - secretName: chart-example-tls
      #    hosts:
      #      - chart-example.local

  persistence:
    config:
      # -- Enables or disables the persistence item. Defaults to true
      enabled: false
      # -- Sets the persistence type
      # Valid options are persistentVolumeClaim, emptyDir, nfs, hostPath, secret, configMap or custom
      type: persistentVolumeClaim
      # -- Storage Class for the config volume.
      # If set to `-`, dynamic provisioning is disabled.
      # If set to something else, the given storageClass is used.
      # If undefined (the default) or set to null, no storageClassName spec is set, choosing the default provisioner.
      storageClass:
      # -- If you want to reuse an existing claim, the name of the existing PVC can be passed here.
      existingClaim:
      # -- AccessMode for the persistent volume.
      # Make sure to select an access mode that is supported by your storage provider!
      # [[ref]](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes)
      accessMode: ReadWriteOnce
      # -- The amount of storage that is requested for the persistent volume.
      size: 1Gi
      # -- Set to true to retain the PVC upon `helm uninstall`
      retain: false
      # -- Configure mounts to all controllers and containers. By default the persistence item
      # will be mounted to `/<name_of_the_peristence_item>`.
      # Example:
      # globalMounts:
      #   - path: /config
      #     readOnly: false
      globalMounts:
        - path: /config

    downloads:
      # -- Enables or disables the persistence item. Defaults to true
      enabled: false
      # -- Sets the persistence type
      # Valid options are persistentVolumeClaim, emptyDir, nfs, hostPath, secret, configMap or custom
      type: persistentVolumeClaim
      # -- Storage Class for the config volume.
      # If set to `-`, dynamic provisioning is disabled.
      # If set to something else, the given storageClass is used.
      # If undefined (the default) or set to null, no storageClassName spec is set, choosing the default provisioner.
      storageClass:
      # -- If you want to reuse an existing claim, the name of the existing PVC can be passed here.
      existingClaim:
      # -- AccessMode for the persistent volume.
      # Make sure to select an access mode that is supported by your storage provider!
      # [[ref]](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes)
      accessMode: ReadWriteOnce
      # -- The amount of storage that is requested for the persistent volume.
      size: 1Gi
      # -- Set to true to retain the PVC upon `helm uninstall`
      retain: false
      # -- Configure mounts to all controllers and containers. By default the persistence item
      # will be mounted to `/<name_of_the_peristence_item>`.
      # Example:
      # globalMounts:
      #   - path: /config
      #     readOnly: false
      globalMounts:
        - path: /downloads

    books:
      # -- Enables or disables the persistence item. Defaults to true
      enabled: false
      # -- Sets the persistence type
      # Valid options are persistentVolumeClaim, emptyDir, nfs, hostPath, secret, configMap or custom
      type: persistentVolumeClaim
      # -- Storage Class for the config volume.
      # If set to `-`, dynamic provisioning is disabled.
      # If set to something else, the given storageClass is used.
      # If undefined (the default) or set to null, no storageClassName spec is set, choosing the default provisioner.
      storageClass:
      # -- If you want to reuse an existing claim, the name of the existing PVC can be passed here.
      existingClaim:
      # -- AccessMode for the persistent volume.
      # Make sure to select an access mode that is supported by your storage provider!
      # [[ref]](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes)
      accessMode: ReadWriteOnce
      # -- The amount of storage that is requested for the persistent volume.
      size: 1Gi
      # -- Set to true to retain the PVC upon `helm uninstall`
      retain: false
      # -- Configure mounts to all controllers and containers. By default the persistence item
      # will be mounted to `/<name_of_the_peristence_item>`.
      # Example:
      # globalMounts:
      #   - path: /config
      #     readOnly: false
      globalMounts:
        - path: /books
